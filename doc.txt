
- hvordan finne query som er ?


statiske queries - kompilering.
ad-hoc queris - 

bør være samme API.
Men hvordan trigge kompilering? Vi kompilerer alltid. Men skjer dette i siste? Eller bare en end().
Vi vet ikke i builder om er flere etterpå.
Kanskje beste er å legge til compile() som en egen greie i builderen.
Og så execute() som egen opsjon, samme interface på det kompilerte som på den andre.
Men kan være lurt å gå veien via compile() uansett slik at viser at det er et kompileringssteg som tar tid og som vil finne sted før en kan eksekvere.


For det kompilerte queryet så kan en da gjøre executeOn(...)
med shorthands for collections, sets, lister osv.



Må sende inn parametre

 - for tabeller
 - for variabler, om er satt.

 - må kunne mikse variabler og konstanter.


executeWith(b -> b.set(param, value)
.on(l ->)

execute(b ->
 b
 .set(param, value)
 .on(pojo())
 .on(Foo.class, fooList)
 .on(Bar.class, barList))


executeOn(dataSource)
	.with(x)
        .and(foo).as(fkfk)
	.and(ba).as(baz)
.get();


---


alias vs tabell.

Resolves i executoren.






-----



Combined-queries ?




andLower(foo::bar)

and(o -> o.lower(foo::bar)).

and(lower(foo::bar))

and().lower(foo::bar)

sum(foo::bar)

sum().distinct(foo::bar)


==

* andLower(foo::bar)
  - tyngre å lese and vs or?
  - mange kombinasjoner - mange forslag i IDen
  + 

* and(o -> o.lower(foo::bar))
  - verbost
  - kræsjer med vanlig tabellrader.

* and(lower(foo::bar))
  and(lower(trim(foo::bar)))
 - mere paranteser å nøste
 - må inkludere static, eller være i interface som implementeres.
 - må alltid allokere nye instanser og returnere
 - andre kan sende inn ikke-kompatible instanser.

 + parantesene scoper brukbart
  (-) er egentlig ikke scopet likevel - siden returnerer instans utenfra.


* and().lower(foo::bar)
  and().lower().trim(foo::bar)

 - ikke scopet (men er heller ikke hele and-en uansett)
 + ikke prototye kræsj
 + fleksiblelt med å legge til mere.
 + færre kombinasjoner

--

Om skulle nøste:

and(field(foo::bar).isEqualTo("baz"))

bedre med:
and(foo::bar).isEqualTo("baz")


an
--

subselects:

and().select().sum(foo::bar).from(foo).isGreaterThan(10)

 - Bedre å scope? Vanskelig å lese at er subselect

and(sum(foo::bar).from(foo)).isGreaterThan(10)
 - fortsatt litt vanskelig å lese?
 - må ha static
 + scopa
 
and(s -> s.sum(foo::bar).from(foo)).isGreaterThan(10)

 - litt verbost
 - kan kræsje på signatur?
 + mere scopa, mere klart skille
 + kaller intern builder

------

Selections fra ?
Kunne vi kutta From? Måtte da hatt aliasene i context.
Men aliasene er egentlig From.
Men hva med tabeller? Her må vi ha from, ellers vet vi ikke tabellene, måtte eksekvert på alle managed entities.
Eventuelt pre-registrert de i q.


q.select(Foo::company)
.leftJoin(Foo.class, Bar.class).
.leftOuterJoin(Foo.class, Bar.class).
.innerJoin(Foo.class, Bar.class)
.where()


private static final Select q = select();


Foo foo = q.alias(Foo.class);

final List<Foo> fooList;

q.sum(foo::getNumber).of(fooList)

Færrest mulig allokeringer, kan pre-kompilere query.

q.where(Foo::getNumber).isEqualTo(1).of(fooList);

q.select(Foo.class).where(foo -> fo.getNumber() == 1).of(fooList);

---

Shorthands for liste-behandling?

int sum = sum(Foo::getNumber).of(fooList);



Kan



================


Joins osv. på lister


Enkle queries:

sum(Foo::getBar).from(fooList)

Trenger vi å lage metoder? Har statisk typesikkerhet så kan bare eksekvere direkte og summere i disse enkle tilfellene hvor det ikke er joins.
Hva når det er joins? Trenger antakelig ikke kompilere her heller.


Flere tilfeller:

 - lokal runtime (eks: desktop) : trenger ikke kompilering 
 - compile-time => JS generering: Må vite metadata for å kompilere.
 - compile-time + reflection: Når skal generere JS, må vite hvilke metoder/VOer vi skal krysskompilere
 - compile-time + reflection: Når skal sammenligne med eksisterende metadata som DB tabeller


Når trenger vi vite from() klassene? Viktig for å finne typene. Kan vi bruke generic-typen?
Fint om kan se på denne for å finne typene som vi skal kryss-kompilere for.

Hvis ikke så kunne en funnet dette via en Query som en sender med.


-----


POJO eksekvering.

Enkel: 
 - løkke med evaluering and eller or
 - emit løkke-over-data? Eller bare kode JS som evaluerer query-struktur?
  * nok bedre å emitte spesialisert kode. Trenger reflection.


Joins:

 - inner-join
  * gjette hvilken entry som gir færrest treff? Mest sansynlig den med færres entries.
  * lage Set<> av join criteria
  * loope over andre. Mulig er kjappere å sjekke test enn join-criteria, kommer an på.

 Lager slutt-resultat liste.

 - outer-join
   * må loope over den som ikke er outer for *kun* disse skal med.
   * må så loope over andre og ta med alle som matcher, selv om ikke matcher de andre.


Multiple inner-joins?


Hvordan få til JPQL-syntax der looper over en collection som et alias?
Se JPQL inner join syntax.
Eller bare skippe denne?


Kort-syntax for lister

select(Foo::getFoo, Bar::getBar)
  .join(fooList).to(barList)
	.on(Foo::getId).isEqualTo(Bar::getFooId)

Men vi ønsker deklarativt så da måtte vi hatt typer eller parametre  


select(Foo::getFoo, Bar::getBar)
  .join(Foo::getId).to(Bar::getFooId)

eller bare som under om vi kjenner foreign keys.

select(Foo::getFoo, Bar::getBar)
  .join(Foo.class).to(Bar.class)

Men hva om vi har flere mulige måter å joine på ? For JPA kan ha flere mulig collections. Bedre å bare skippe denne muligheten?


select(Foo::getFoo, Bar::getBar)
  .join(Foo::getAllBars)

Med aliaser ? Unngå dette inntil motsatte er bevist.

select(Foo::getFoo, barAlias::getBar)
  .join(Foo::getAllBars).as(barAlias)


Hvis vet en datasource først så kan vi finne select-sourcene ganske enkelt,
kan også komprimere de bra.

Trenger ikke from().
Men får ikke kompilert getterne uten from().

Så kan være nyttig med å ha en query-greie som på forhånd vet om entitetene.

private static final Select select = jpa("query-unit-noe");

Så kan vi cache de typene som behøvs, selv om mange å søke igjennom i starten.
Kan dele de statisk når vi bygger query.

Så vi må ha en kilde for type-info i så fall, da slipper vi from() som bare er redundant.
from() kan være fint for å se hva som er med i query så kunne være optional evt.

Uansett å vite på forhånd alle typer som kan oppstå.

select.sum(Foo::getFoo)
.where(Foo::getBar).gt(10)
  .and().lower(Foo::getBaz).startsWith("baz");


Så vi har et generelt "typespace" som vi sette inn i query.


====


Hvordan uttrykke query som JavaScript?
vi outputter JS-løkker som utfører and-en på data direkte.

Så vi må ha doOrLoop(<noe som representerer lista>) som genererer kode.

Så vi har en QueryExecutor som for JS bare samler opp JSen mens for Java regner ut resultatet.

Viktigste er å beholde samme optimaliserings-logikk i JS og Java med hva vi itererere først og siste, altså samme (enkle) query planner.

Men ikke vits i å optimalisere veldig i starten, mest å holde mulighetene åpne for dette.


===

OBS! Dynamiske queries? Med data som blir oppdatert asynkront i bakgrunnen. Har med paging å gjøre, første synlige element osv.
Kan holde første synlige element i lista stabilt og oppdatere resten i GUI dynamisk.
Samme problematikk som Nebula gallery.


===


TypeSpace:

- TypeSpace må kunne ha et API som gjør at kan bit-pakkes senere for å kun lage en enkel instans for ad-hoc queries.
Men for AdHoc er det mulig er mere aktuelt med å bare samle lambdaene.
Så to arrays. Issue er at vi ikke vet på forhånd hvor stort query er.

 - korte queries : et par-tre harkoda ops og lambdaer slik at holder med en enkelt instans i minne.
 - lange queries : arrays som vi lager etter hvert med opsjonene som trengs. Så vi allokerere arrays-ene så fort trengs for å eksekvere. Antakeligvis en god del raskere enn Streams
siden bare en enkelt allokering i enkle tilfeller.


- Men i starten er det prekompilerte queries som gjelder, for hvis ikke vil de ikke kunne anvendes for web.


- Vi ser ikke på om datasource er local eller remote, vi definerer JPA direkte og select()er ut av dise.

===

Tre-bygging. Må kunne bygge trær rett ut av selectene inn i result-VOer.
Må være hensiktsmessig i forhold til GUI-trær slik at kan select()e rett fra GUI (men DAO-lag ønskelig? Trenger da konkrete VO typer å jobbe på).
Antakelig det beste å ikke tillate select-er fra DB/persistent DS direkte fra views. Bør alltid gå gjnnom modellen, som returnere VOer av noe slag.


===

Bør ha query-API som ikke antar egne sub instanser? Men kan fikses senere.

===





---


- Kan ha conditions som er for flere kilder.
- alle join conditions må være spesifisert i joins
- 


- sorterer på source (alias eller klasse - er vel name egentlig)
- vi looper over og finner alle som matcher for å slippe gjøre noe med datastruktur. Må ha iterator-lignende for dette som opererer på indekser, dvs int.

 * når vi genererer query så emitter vi sjekk for hver enkelt av queryiene som matcher. Så vi finner hver enkelt i inputen som matcher "vår" join og emitter koden for denne
uavhengig.


Subselects ? Emittes som ekstra kall? Kan ha input parametre som skal matches for hver rad som er utført.



-----


Enkel non-set Join i løkke?

Må joine mot alle andre, så kan kun beregne joins helt til slutt i innester løkka?

Men joiner på andre felter, joiner på IDene mellom de.

Så slik sett på hvert nivå.
Men retning på joins? Joiner mot de som er tidligere i rekursjon for med de som er senere så joiner vi motsatt vei.



















