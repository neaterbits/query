
- hvordan finne query som er ?


statiske queries - kompilering.
ad-hoc queris - 

bør være samme API.
Men hvordan trigge kompilering? Vi kompilerer alltid. Men skjer dette i siste? Eller bare en end().
Vi vet ikke i builder om er flere etterpå.
Kanskje beste er å legge til compile() som en egen greie i builderen.
Og så execute() som egen opsjon, samme interface på det kompilerte som på den andre.
Men kan være lurt å gå veien via compile() uansett slik at viser at det er et kompileringssteg som tar tid og som vil finne sted før en kan eksekvere.


For det kompilerte queryet så kan en da gjøre executeOn(...)
med shorthands for collections, sets, lister osv.



Må sende inn parametre

 - for tabeller
 - for variabler, om er satt.

 - må kunne mikse variabler og konstanter.


executeWith(b -> b.set(param, value)
.on(l ->)

execute(b ->
 b
 .set(param, value)
 .on(pojo())
 .on(Foo.class, fooList)
 .on(Bar.class, barList))


executeOn(dataSource)
	.with(x)
        .and(foo).as(fkfk)
	.and(ba).as(baz)
.get();


---


alias vs tabell.

Resolves i executoren.






-----



Combined-queries ?




andLower(foo::bar)

and(o -> o.lower(foo::bar)).

and(lower(foo::bar))

and().lower(foo::bar)

sum(foo::bar)

sum().distinct(foo::bar)


==

* andLower(foo::bar)
  - tyngre å lese and vs or?
  - mange kombinasjoner - mange forslag i IDen
  + 

* and(o -> o.lower(foo::bar))
  - verbost
  - kræsjer med vanlig tabellrader.

* and(lower(foo::bar))
  and(lower(trim(foo::bar)))
 - mere paranteser å nøste
 - må inkludere static, eller være i interface som implementeres.
 - må alltid allokere nye instanser og returnere
 - andre kan sende inn ikke-kompatible instanser.

 + parantesene scoper brukbart
  (-) er egentlig ikke scopet likevel - siden returnerer instans utenfra.


* and().lower(foo::bar)
  and().lower().trim(foo::bar)

 - ikke scopet (men er heller ikke hele and-en uansett siden ikke i lambda)
 + ikke prototye kræsj
 + fleksiblelt med å legge til mere.
 + færre kombinasjoner

--

Om skulle nøste:

and(field(foo::bar).isEqualTo("baz"))

bedre med:
and(foo::bar).isEqualTo("baz")


an
--

subselects:

and().select().sum(foo::bar).from(foo).isGreaterThan(10)

 - Bedre å scope? Vanskelig å lese at er subselect

and(sum(foo::bar).from(foo)).isGreaterThan(10)
 - fortsatt litt vanskelig å lese?
 - må ha static
 + scopa
 
and(s -> s.sum(foo::bar).from(foo)).isGreaterThan(10)

 - litt verbost
 - kan kræsje på signatur?
 + mere scopa, mere klart skille
 + kaller intern builder

------

Selections fra ?
Kunne vi kutta From? Måtte da hatt aliasene i context.
Men aliasene er egentlig From.
Men hva med tabeller? Her må vi ha from, ellers vet vi ikke tabellene, måtte eksekvert på alle managed entities.
Eventuelt pre-registrert de i q.


q.select(Foo::company)
.leftJoin(Foo.class, Bar.class).
.leftOuterJoin(Foo.class, Bar.class).
.innerJoin(Foo.class, Bar.class)
.where()


private static final Select q = select();


Foo foo = q.alias(Foo.class);

final List<Foo> fooList;

q.sum(foo::getNumber).of(fooList)

Færrest mulig allokeringer, kan pre-kompilere query.

q.where(Foo::getNumber).isEqualTo(1).of(fooList);

q.select(Foo.class).where(foo -> fo.getNumber() == 1).of(fooList);

---

Shorthands for liste-behandling?

int sum = sum(Foo::getNumber).of(fooList);



Kan



================


Joins osv. på lister


Enkle queries:

sum(Foo::getBar).from(fooList)

Trenger vi å lage metoder? Har statisk typesikkerhet så kan bare eksekvere direkte og summere i disse enkle tilfellene hvor det ikke er joins.
Hva når det er joins? Trenger antakelig ikke kompilere her heller.


Flere tilfeller:

 - lokal runtime (eks: desktop) : trenger ikke kompilering 
 - compile-time => JS generering: Må vite metadata for å kompilere.
 - compile-time + reflection: Når skal generere JS, må vite hvilke metoder/VOer vi skal krysskompilere
 - compile-time + reflection: Når skal sammenligne med eksisterende metadata som DB tabeller


Når trenger vi vite from() klassene? Viktig for å finne typene. Kan vi bruke generic-typen?
Fint om kan se på denne for å finne typene som vi skal kryss-kompilere for.

Hvis ikke så kunne en funnet dette via en Query som en sender med.


-----


POJO eksekvering.

Enkel: 
 - løkke med evaluering and eller or
 - emit løkke-over-data? Eller bare kode JS som evaluerer query-struktur?
  * nok bedre å emitte spesialisert kode. Trenger reflection.


Joins:

 - inner-join
  * gjette hvilken entry som gir færrest treff? Mest sansynlig den med færres entries.
  * lage Set<> av join criteria
  * loope over andre. Mulig er kjappere å sjekke test enn join-criteria, kommer an på.

 Lager slutt-resultat liste.

 - outer-join
   * må loope over den som ikke er outer for *kun* disse skal med.
   * må så loope over andre og ta med alle som matcher, selv om ikke matcher de andre.


Multiple inner-joins?


Hvordan få til JPQL-syntax der looper over en collection som et alias?
Se JPQL inner join syntax.
Eller bare skippe denne?


Kort-syntax for lister

select(Foo::getFoo, Bar::getBar)
  .join(fooList).to(barList)
	.on(Foo::getId).isEqualTo(Bar::getFooId)

Men vi ønsker deklarativt så da måtte vi hatt typer eller parametre  


select(Foo::getFoo, Bar::getBar)
  .join(Foo::getId).to(Bar::getFooId)

eller bare som under om vi kjenner foreign keys.

select(Foo::getFoo, Bar::getBar)
  .join(Foo.class).to(Bar.class)

Men hva om vi har flere mulige måter å joine på ? For JPA kan ha flere mulig collections. Bedre å bare skippe denne muligheten?


select(Foo::getFoo, Bar::getBar)
  .join(Foo::getAllBars)

Med aliaser ? Unngå dette inntil motsatte er bevist.

select(Foo::getFoo, barAlias::getBar)
  .join(Foo::getAllBars).as(barAlias)


Hvis vet en datasource først så kan vi finne select-sourcene ganske enkelt,
kan også komprimere de bra.

Trenger ikke from().
Men får ikke kompilert getterne uten from().

Så kan være nyttig med å ha en query-greie som på forhånd vet om entitetene.

private static final Select select = jpa("query-unit-noe");

Så kan vi cache de typene som behøvs, selv om mange å søke igjennom i starten.
Kan dele de statisk når vi bygger query.

Så vi må ha en kilde for type-info i så fall, da slipper vi from() som bare er redundant.
from() kan være fint for å se hva som er med i query så kunne være optional evt.

Uansett å vite på forhånd alle typer som kan oppstå.

select.sum(Foo::getFoo)
.where(Foo::getBar).gt(10)
  .and().lower(Foo::getBaz).startsWith("baz");


Så vi har et generelt "typespace" som vi sette inn i query.


====


Hvordan uttrykke query som JavaScript?
vi outputter JS-løkker som utfører and-en på data direkte.

Så vi må ha doOrLoop(<noe som representerer lista>) som genererer kode.

Så vi har en QueryExecutor som for JS bare samler opp JSen mens for Java regner ut resultatet.

Viktigste er å beholde samme optimaliserings-logikk i JS og Java med hva vi itererere først og siste, altså samme (enkle) query planner.

Men ikke vits i å optimalisere veldig i starten, mest å holde mulighetene åpne for dette.


===

OBS! Dynamiske queries? Med data som blir oppdatert asynkront i bakgrunnen. Har med paging å gjøre, første synlige element osv.
Kan holde første synlige element i lista stabilt og oppdatere resten i GUI dynamisk.
Samme problematikk som Nebula gallery.


===


TypeSpace:

- TypeSpace må kunne ha et API som gjør at kan bit-pakkes senere for å kun lage en enkel instans for ad-hoc queries.
Men for AdHoc er det mulig er mere aktuelt med å bare samle lambdaene.
Så to arrays. Issue er at vi ikke vet på forhånd hvor stort query er.

 - korte queries : et par-tre harkoda ops og lambdaer slik at holder med en enkelt instans i minne.
 - lange queries : arrays som vi lager etter hvert med opsjonene som trengs. Så vi allokerere arrays-ene så fort trengs for å eksekvere. Antakeligvis en god del raskere enn Streams
siden bare en enkelt allokering i enkle tilfeller.


- Men i starten er det prekompilerte queries som gjelder, for hvis ikke vil de ikke kunne anvendes for web.


- Vi ser ikke på om datasource er local eller remote, vi definerer JPA direkte og select()er ut av dise.

===

Tre-bygging. Må kunne bygge trær rett ut av selectene inn i result-VOer.
Må være hensiktsmessig i forhold til GUI-trær slik at kan select()e rett fra GUI (men DAO-lag ønskelig? Trenger da konkrete VO typer å jobbe på).
Antakelig det beste å ikke tillate select-er fra DB/persistent DS direkte fra views. Bør alltid gå gjnnom modellen, som returnere VOer av noe slag.


===

Bør ha query-API som ikke antar egne sub instanser? Men kan fikses senere.

===





---


- Kan ha conditions som er for flere kilder.
- alle join conditions må være spesifisert i joins
- 


- sorterer på source (alias eller klasse - er vel name egentlig)
- vi looper over og finner alle som matcher for å slippe gjøre noe med datastruktur. Må ha iterator-lignende for dette som opererer på indekser, dvs int.

 * når vi genererer query så emitter vi sjekk for hver enkelt av queryiene som matcher. Så vi finner hver enkelt i inputen som matcher "vår" join og emitter koden for denne
uavhengig.


Subselects ? Emittes som ekstra kall? Kan ha input parametre som skal matches for hver rad som er utført.



-----


Enkel non-set Join i løkke?

Må joine mot alle andre, så kan kun beregne joins helt til slutt i innester løkka?

Men joiner på andre felter, joiner på IDene mellom de.

Så slik sett på hvert nivå.
Men retning på joins? Joiner mot de som er tidligere i rekursjon for med de som er senere så joiner vi motsatt vei.




JPA joins? Må i første omgang joine på collections antakelig.
Så må ha en måte å spesifisere dette på.

Behøvs egentlig bare selve collection som skal joins på, men kan ha en verbos versjon her også.


join()

Burde ha bare on(foo::getFooBar)

Siden vi ikke joiner på felter. Men burde kunne custom-joine også som vi uttrykker enten i where-clause eller i JPA >= 2.1 joins.


----














----


		/*
			System.out.println("## generic return type: " + m.getGenericReturnType().getTypeName());
			
			final Type type = m.getGenericReturnType();
			
			final ParameterizedType genReturnType = (ParameterizedType)type;

			final Type collectionMemberType = genReturnType.getActualTypeArguments()[0];
			
			System.out.println("## generic return class: " + ((Class<?>)collectionMemberType).getName());
			
			
			System.out.println("## found collection attribute " + attr.getName() + " of type " + attr.getJavaType() + ", generic type " +
							Arrays.toString(attr.getJavaType().getTypeParameters())); // [0getGenericInterfaces()));
		*/




		
		final OneToMany oneToMany = accessible.getDeclaredAnnotation(OneToMany.class);
		
		if (oneToMany == null) {
			throw new UnsupportedOperationException("No one-to-many for ");
		}



		// Check whether target is same as toClass
		if (memberType == null) {
			memberType = oneToMany.targetEntity();
			
			if (memberType == null) {
				throw new IllegalStateException("memberType neither specified with generics nor through members");
			}
		}

		final Relation ret;

		if (memberType.equals(toClass)) {
			// Relation from one to other
			final RelationField from = new RelationField(fromClass, makeEntityAttribute(attr));
			final RelationField to = new RelationField(toClass, toEntity, findToAttrOrForMappedByException(toEntity, oneToMany.mappedBy()));

			ret = new Relation(from, to);
		}
		else {
			ret = null;
		}



----


Input API for resolve ?

 * Må scanne etter IDer for join-en basert på meta-modell.
 * hvis ikke finnes meta-modell så må vi se på innhold i selve listene og joine mot de? Dvs alle som har liste-element som inneholder slik-og-slik.

Hvordan oppgi meta-modell? Bør være noe i data-sourcen til POJOen i prepare?

Må ha et sette med metadata-scannes som legges inn.
Dette burde egentlig være i query-contexten som opprettes et annet sted.

select.first()

select = Query.pojo();

select = Query.universal();







Hvordan joine tilbake på innholdet? Må se på kolonna som har et gitt innhold.
Men gir dette egentlig mening? Er bare join tilbake på instansen. Så må finne den som inneholder link til instansen
		og sammenligne identity eller bare IDen.
		Om ikke er hverken i liste eller reverse så kan vi ikke joine.




----


Neste:

% - adhoc queries med mininmalt overhead
  ! IAdhocAndClauses er ikke typesafe, type parameteren må være typen vi opererer på akkurat nå. OBS! Dette bør kunne gjenbrukes
    for vanlige queries også siden gir mere strukturert syntaks.

  Hvordan skille disse? Er to forskjellige typer, Checked og Unchecked der adhoc er Checked.
  
# - rename av Class / Table => Entity (i motsetning til Alias) slik at blir konsistent.
Renamed til Named
#  - nøsta and/or
 - in
# - bedre debugging av in-memory query eksekvering
 - parametere
 - unit tester rett på JPAModel og utils for å sjekke at henter ut relations riktig, attributt kolonner mm på rett vis.
   * se om bør endre API slik at eget for å hente kolonner for relation attributter?

 - dialekter, dvs statisk begrense muligheter (kun ANSI joins?)
 - query ut fra context variabel
   * forenklede queries uten from eller join sources. Trenge ikke from/implisitt join om kun ANSI joins
 - subselects
 - mere tester
 - transformasjons-API
 - optionals
 - JS / annen kode generering ut fra POJO joins
 - lagre/slette-API som er uavhengig av JPA
   * batch insert/update
 - hibernate direkte støtte? Mulig kan gjenbruke en del fra JPA



----



adhoc query

list()   .from(fooList) . where(Foo::getBar) . isEqualTo("baz");
one()    .from(fooList) . where(Foo::getBar) . isEqualTo("baz");
first(10).from(fooList) . where(foo::getBar) . isEqualTo("baz");

list(Foo::getBar).from(fooList).where(Foo::getBar).startsWith("baz")

sum(Foo::getBaz).from(fooList).where(Foo::getBar).startsWith("baz")

sum().from(intList).where().greaterThan(1);

sum(intList).greaterThan(1);


flatten(Foo::getSubs)
	.from(fooList)
	.where(Foo::getBar).startsWith("baz")
	.  and(Sub::getFoo).isEqualTo(1);













---



list(fooLis)
   .join(sub).on(Main::foo).isEqualTo(Sub::bar)
	.where(Sub::var).isLessThan(10)
   .join() 


list(fooLis)
   .join(sub, j-> j.on(Main::foo).isEqualTo(Sub::bar). 
		.join(subSub, j2 -> j2
			.on(Sub::bar).isEqualTo(SubSub::baz)
 			.where(SubSub:baz).isEqualTo(19))

		.where(Sub::var).isLessThan(10)
   .where()




---------


Hvordan fikse conditions etter joins?
Setter selectSourceIdx til siste kjente men denne har blitt inkrementert av join.
Dette gjelder også nøstede joins, vi må lagre unna den opprinnelige noe sted.

Kan benytte conditions idx direkte og sette denne tidlig, men hvordan finne tilbake?

Er vi på ytterste nivå kan vi anta source 0, for joins så må vi instansiere uansett så da kan vi mellomlagre der.



---


where-joins på innerste nivå stemmer ikke med ConditionsType.
Issue? Gjør det vanskelig med and-or kombinasjoner nedover i nøstinga.

and foo.x = 1
and bar.y > 2

Her joiner vi så ikke like lett å løse, får conditions som tilhører join'en i stedet.

Egentlig en nøsta and-or dette side vi joiner så er det AND mellom alle.
Så er "or" i en join så må vi nøste med and.

Og Join-API må støtte nøsting uansett.

Så en condition kan være SUB eller COMPARE, her blir det sub som peker til et sett med andre conditions. Men de kan ligge i samme tabellene.


Så hver join får sin egen sub, men bare om har joins. Men vi finner ut om har joins før conditions på topp-nivå.

Eller skal vi legge inn conditions på join-nivå i stedet ?

Skal uansett håndtere sub-conditions, hvordan? Kan ha en array av nøstede levels med indekser for sub-conditions som vi evaluerer nedover.

evaluateCondition(int [] indices)

Eller holde styr på en link? Men må vite når vi skal returnere tilbake

Det er i så fall getConditionCount() lignende som må brukes til å navigere.

E

int getSubConditionCount(int conditionIdx);

int getSubConditionStartIdx(int conditionIdx);


Og så anta at conditions er i stigende rekkefølge? I stedet for at sender inn array med hele pathen.

Hvis array så må vi sende inn en array av pathen som krever ekstra allokering.

Lage egen helper-klasse for management av arrayen? Eller utility-funksjoner.
Men er multiple arrays i ett tilfelle.

Men er kun om har subs eller joins at trenger arrays for disse.


--

For vanlige joins blir dette et litt underlig API siden må bruke samme algoritme for å ekspandere.

Så greit med en utility-klasse for management av arrayene ?






----



Joins:

 * implicit join i from-clausen
 * explicit join (ANSI join)

OBS! Kan ikke ha samme alias i begge, må fjerne fra from om finnes (m/warning?)

Bør tillate i query-generering men fjerne fra syntax, ihvertfall den forenklede.

Kun nøsta-joins? Men blir ikke typesjekking ved alias uansett.


Men har da to typer SelectSources
 - fra from
 - fra join

- Må kunne søke på de
- Må kunne fjerne from 'from' når er duplikat. Gjøre dette under kompilering og tildeling av indekser.


Så må endre noe på CompiledSelectSources ? Kan ha flere sources, både from og join.

Hvordan fikse indeks tildelingen i så fall?
Antalig best å oppdatere indeksene til slutt.

Hvis ikke må ha ett steg til i kompileringen.
Men bør ha dette uansett? Sources er uavhengig av from/to og disse opprettes i etterkant?
Omtrent som SelectSource.

Så bare en liste over kjente sources som vi søker i? med remove() osv.



----


Nøsta and/ors.


and(o -> o.where(Foo::getBar).			)


 - ser for mye ut som subselect
 + nøsta


and(o -> o.or(Foo::getBar).or()			)

 - or først ser rart ut

andAny(Foo::getBar).or(Bar::getBaz)
.and(Foo::) // and avslutter konteksten

 - avhengig av indenterug for lesbarhet, vanskelig å skille dobbel nøsting
 + kan vøre mere lesbart



.and(o -> o.any(Foo::getBar).or (Bar::getBaz) )

. or(a -> a.all(Foo::getBar).and(Bar::getBaz) )

 - fortsatt ikke kjempe lesbart
 + nøsta så parantesene sier hva som er logikken



##

Hvordan differensiere fra subselects? Funker ikke å bare sende inn en annen builder for da vil en få ambiguity?
Kan teste om så er tilfelle.

.and(s -> s.select().first(xyz).from()) . isEqualTo("123").

Kunne det lønt seg å sende inn verdien først? Er mere lesbart siden ellers vil .isEqualTo() forsvinne i andre koden, men om er først så blir det motsatt fra hva som er ellers.
Kan likevel virke litt for mye tilpasning å sny på flisa, man er vant til å skrive kolonne først, ikke parameteren. Så antakelig ok å sende inn query først.
Gjør også at vi vet at dette er en subselect og kan gjøre valg i builderen vi returnerer.

---

For adhoc queries, så MÅ vi kode typen rett inn i AND/OR interfacene for at skal bli riktig statisk typesjekking, ellers så kan en sende inn hva som helst,
dvs om er <T> i input interfacet i stede for i parameteren.
Så er et bra starting point å opprette eget her, slik at vi kan fortsette med IShared<> .

interfaces for and?
 - subinterface builder for any() og all() som har StringFunction osv (så blir en del duplisering .. men har ikke noen betydning her). Men ser ut som like greit å bare ha and() først.

 - returnerer samme som for topp-nivå and() eller or() og som retur-type for Comparatoene, dvs AndClauses eller OrClauses.


Hvordan lagre nøstingen? Må allokere ny instans. Bare gjenbruke query-klassen som vi har? Antakelig det enkleste, bare sette i rett initial-state.
Trenger ikke vite om er List eller Set her, kan ha AdhocConditionsNested siden vi uansett ikke skal gjøre get() for å hente ut noe resultat,
er kun for å lagre unna conditions.

OK stryk forrige, ser ut som AdhocConditions allerede er separat så kan bare nøste disse.


---

Bør rydde i table/entity/class


table:
 - database spesifikt, passer ikke med Pojo
 + ??

entity:
 - vagt
 + generisk
 + gjenbrukt i JPA


class:

 - pojo spesifikt
 + kjent



Kontra er alias

Det motsatte av alias er concrete kanskje, men tror satser på Entity


---




 


@FunctionalInterface
public interface ISharedSubOr<MODEL, RESULT, OR_CLAUSES extends ISharedOrClauses<MODEL, RESULT>> extends Consumer<OR_CLAUSES> {

}






	modified:   sql-dsl/src/main/java/com/neaterbits/query/sql/dsl/api/ISharedAndClausesAlias.java

no changes added to commit (use "git add" and/or "git commit -a")
nhl@nhl-SATELLITE-P50-A-11J:~/projects/all-neon/query$ git diff sql-dsl/src/main/java/com/neaterbits/query/sql/dsl/api/ISharedAndClausesAlias.java
diff --git a/sql-dsl/src/main/java/com/neaterbits/query/sql/dsl/api/ISharedAndClausesAlias.java b/sql-dsl/src/main/java/com/neaterbits/query/sql/dsl/api/ISharedAndClausesAlias.java
index 6114dd8..6bc7bf6 100644
--- a/sql-dsl/src/main/java/com/neaterbits/query/sql/dsl/api/ISharedAndClausesAlias.java
+++ b/sql-dsl/src/main/java/com/neaterbits/query/sql/dsl/api/ISharedAndClausesAlias.java
@@ -8,5 +8,8 @@ public interface ISharedAndClausesAlias<MODEL, RESULT, AND_CLAUSES extends IShar
        ISharedConditionClauseAlias<MODEL, RESULT, Long, AND_CLAUSES> and(ISupplierLong getter);
 
     ISharedClauseComparableStringAll<MODEL, RESULT, AND_CLAUSES> and(ISupplierString getter);
+    
+    <SUB_OR_CLAUSES extends ISharedOrClausesAlias<MODEL, RESULT, SUB_OR_CLAUSES>>
+               ISharedAndClausesAlias<MODEL, RESULT, AND_CLAUSES> and(ISharedSubOr<MODEL, RESULT, SUB_OR_CLAUSES> orBuilder);
 
 }




-----



package com.neaterbits.query.sql.dsl.api;

public interface ISharedOrClausesNamedValues<MODEL, RESULT, OR_CLAUSES extends ISharedOrClausesNamedValues<MODEL, RESULT, OR_CLAUSES>>

		extends ISharedOrClausesNamedBase<
			MODEL,
			RESULT,
			OR_CLAUSES,
			
			ISharedClauseComparableCommonValue<MODEL, RESULT, Integer, OR_CLAUSES>,
			ISharedClauseComparableCommonValue<MODEL, RESULT, Long, OR_CLAUSES>,
			ISharedClauseComparableStringValue<MODEL, RESULT, OR_CLAUSES>> {

}

