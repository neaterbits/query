<html>
<head>

	<base href="..">
	<link href="css/collection_query.css" type="text/css" rel="stylesheet">
</head>
<body>
	<div id="quick_explanation">

		<p class="main_text">
			Query allows you to write typesafe  SQL queries in plain Java 8 on top of JPA or Hibernate and have them mapped into Java objects (e.g JPA managed).
			
			No other dependencies code generation required, just include library and start writing queries!
			
			Advantages:
			 <ul>
			   <li><b>Typesafe</b> queries, in joins, comparison and result transformations</li>
			   <li>As <b>portable</b> as JPQL across databases</li>
			   <li><b>Result transforms</b> are part of queries and typesafe as well, no need to use transformers or resultset casting</li>
			   <li>Supports <b>aliases</b> as in SQL, though table style recommended whenever aliases not required</li>
			   <li><b>Refactoring proof</b>. ename entity fields in yout IDE and your queries will be updated</li>
			   <li>Utilize IDE <b>completion suggestions</b>, Ctrl+SPACE or you favorite IDE's hotkey </li>
			   <li>No code generation required, this is plain Java8 utilizonig JPA annotated classes</li> 
			   <li>Will eventually support all of standard SQL, also widely supported features outside of JPQL can be supported</li>
			   
			 </ul>
		<p>						
			
			<!-- 
		 <span class="main_header2">An example of mapping transformations</span>
		 <br/>
		  -->
		 
		 <!-- TODO use display: table to make same height -->
		 
		 <div class="code_comparison">
		 <div class="code_comparison_row">

			 <pre class="java_code code_lhs">
  List&lt;KBMovieAndActor&gt; kbMovies = select.list(KBMovieAndActor.class)
         .map(Movie::getName) . to(KBMovieAndActor::setMovieName)
         .map(Actor::getName) . to(KBMovieAndActor::setActorName)
         .innerJoin(Movie::getActors)
         .where().lower(Actor::getName).eq("kevin bacon")
         .get();
			 </pre>
	 
			<pre class="sql_code code_rhs">
  Query q = em.createQuery(
         "SELECT movie.name, actor.name " +
         "FROM Movie movie, Actor actor " +
         "INNER JOIN movie.actors actor "
         "WHERE lower(actor.name) = 'kevin bacon'"";
	  		
  List&lt;Object []&gt; l = q.list();
  List&lt;KBMovieAndActor&gt; result = new ArrayList&lt;&gt;(l.size());
	
  for (Object [] row : l) {
    result.add(new KBMovieAndActor((String)row[0], (String)row[1]))
  } 
			</pre>
		</div>
		</div> <!-- code_comparison -->	
		
	</div>
							 

As can be seen above, result transformations happens as an integral part of specifying the columns to select, no need to write separate transformation.
Though the query is not a lot shorter than the one below, it is type safe and refactoring proof.

			 <br/><br/>

			 
			 <span class="main_header2">Where's the from clause?</span>
			 <p>
			 
			 The from clause is quite redundant since we can figure out the tables involved anyway. Cartesian products can be done explicitely.
			 </p>
			 
			 <span class="main_header2">License</span>
			 <p>
			 
			 For now, Query is only available for commercial use.
			 <br/>
			 <b>"What!? Not open source of free of charge?"</b>
			 Not at this moment, see License for rationale.
			 </p>
			 
	</div>

<!-- 		
		<div id="main_menu">
			<div class="main_button">Demo</div>
			<div class="main_button">Foo!</div>
		</div>
		
 -->		

			
</body>
</html>
