
- hvordan finne query som er ?


statiske queries - kompilering.
ad-hoc queris - 

bør være samme API.
Men hvordan trigge kompilering? Vi kompilerer alltid. Men skjer dette i siste? Eller bare en end().
Vi vet ikke i builder om er flere etterpå.
Kanskje beste er å legge til compile() som en egen greie i builderen.
Og så execute() som egen opsjon, samme interface på det kompilerte som på den andre.
Men kan være lurt å gå veien via compile() uansett slik at viser at det er et kompileringssteg som tar tid og som vil finne sted før en kan eksekvere.


For det kompilerte queryet så kan en da gjøre executeOn(...)
med shorthands for collections, sets, lister osv.



Må sende inn parametre

 - for tabeller
 - for variabler, om er satt.

 - må kunne mikse variabler og konstanter.


executeWith(b -> b.set(param, value)
.on(l ->)

execute(b ->
 b
 .set(param, value)
 .on(pojo())
 .on(Foo.class, fooList)
 .on(Bar.class, barList))


executeOn(dataSource)
	.with(x)
        .and(foo).as(fkfk)
	.and(ba).as(baz)
.get();


---


alias vs tabell.

Resolves i executoren.






-----



Combined-queries ?




andLower(foo::bar)

and(o -> o.lower(foo::bar)).

and(lower(foo::bar))

and().lower(foo::bar)

sum(foo::bar)

sum().distinct(foo::bar)


==

* andLower(foo::bar)
  - tyngre å lese and vs or?
  - mange kombinasjoner - mange forslag i IDen
  + 

* and(o -> o.lower(foo::bar))
  - verbost
  - kræsjer med vanlig tabellrader.

* and(lower(foo::bar))
  and(lower(trim(foo::bar)))
 - mere paranteser å nøste
 - må inkludere static, eller være i interface som implementeres.
 - må alltid allokere nye instanser og returnere
 - andre kan sende inn ikke-kompatible instanser.

 + parantesene scoper brukbart
  (-) er egentlig ikke scopet likevel - siden returnerer instans utenfra.


* and().lower(foo::bar)
  and().lower().trim(foo::bar)

 - ikke scopet (men er heller ikke hele and-en uansett siden ikke i lambda)
 + ikke prototye kræsj
 + fleksiblelt med å legge til mere.
 + færre kombinasjoner

--

Om skulle nøste:

and(field(foo::bar).isEqualTo("baz"))

bedre med:
and(foo::bar).isEqualTo("baz")


an
--

subselects:

and().select().sum(foo::bar).from(foo).isGreaterThan(10)

 - Bedre å scope? Vanskelig å lese at er subselect

and(sum(foo::bar).from(foo)).isGreaterThan(10)
 - fortsatt litt vanskelig å lese?
 - må ha static
 + scopa
 
and(s -> s.sum(foo::bar).from(foo)).isGreaterThan(10)

 - litt verbost
 - kan kræsje på signatur?
 + mere scopa, mere klart skille
 + kaller intern builder

------

Selections fra ?
Kunne vi kutta From? Måtte da hatt aliasene i context.
Men aliasene er egentlig From.
Men hva med tabeller? Her må vi ha from, ellers vet vi ikke tabellene, måtte eksekvert på alle managed entities.
Eventuelt pre-registrert de i q.


q.select(Foo::company)
.leftJoin(Foo.class, Bar.class).
.leftOuterJoin(Foo.class, Bar.class).
.innerJoin(Foo.class, Bar.class)

.where()

private static final Select q = select();


Foo foo = q.alias(Foo.class);

final List<Foo> fooList;

q.sum(foo::getNumber).of(fooList)

Færrest mulig allokeringer, kan pre-kompilere query.

q.where(Foo::getNumber).isEqualTo(1).of(fooList);

q.select(Foo.class).where(foo -> fo.getNumber() == 1).of(fooList);

---

Shorthands for liste-behandling?

int sum = sum(Foo::getNumber).of(fooList);



Kan



================


Joins osv. på lister


Enkle queries:

sum(Foo::getBar).from(fooList)

Trenger vi å lage metoder? Har statisk typesikkerhet så kan bare eksekvere direkte og summere i disse enkle tilfellene hvor det ikke er joins.
Hva når det er joins? Trenger antakelig ikke kompilere her heller.


Flere tilfeller:

 - lokal runtime (eks: desktop) : trenger ikke kompilering 
 - compile-time => JS generering: Må vite metadata for å kompilere.
 - compile-time + reflection: Når skal generere JS, må vite hvilke metoder/VOer vi skal krysskompilere
 - compile-time + reflection: Når skal sammenligne med eksisterende metadata som DB tabeller


Når trenger vi vite from() klassene? Viktig for å finne typene. Kan vi bruke generic-typen?
Fint om kan se på denne for å finne typene som vi skal kryss-kompilere for.

Hvis ikke så kunne en funnet dette via en Query som en sender med.


-----


POJO eksekvering.

Enkel: 
 - løkke med evaluering and eller or
 - emit løkke-over-data? Eller bare kode JS som evaluerer query-struktur?
  * nok bedre å emitte spesialisert kode. Trenger reflection.


Joins:

 - inner-join
  * gjette hvilken entry som gir færrest treff? Mest sansynlig den med færres entries.
  * lage Set<> av join criteria
  * loope over andre. Mulig er kjappere å sjekke test enn join-criteria, kommer an på.

 Lager slutt-resultat liste.

 - outer-join
   * må loope over den som ikke er outer for *kun* disse skal med.
   * må så loope over andre og ta med alle som matcher, selv om ikke matcher de andre.


Multiple inner-joins?


Hvordan få til JPQL-syntax der looper over en collection som et alias?
Se JPQL inner join syntax.
Eller bare skippe denne?


Kort-syntax for lister

select(Foo::getFoo, Bar::getBar)
  .join(fooList).to(barList)
	.on(Foo::getId).isEqualTo(Bar::getFooId)

Men vi ønsker deklarativt så da måtte vi hatt typer eller parametre  


select(Foo::getFoo, Bar::getBar)
  .join(Foo::getId).to(Bar::getFooId)

eller bare som under om vi kjenner foreign keys.

select(Foo::getFoo, Bar::getBar)
  .join(Foo.class).to(Bar.class)

Men hva om vi har flere mulige måter å joine på ? For JPA kan ha flere mulig collections. Bedre å bare skippe denne muligheten?


select(Foo::getFoo, Bar::getBar)
  .join(Foo::getAllBars)

Med aliaser ? Unngå dette inntil motsatte er bevist.

select(Foo::getFoo, barAlias::getBar)
  .join(Foo::getAllBars).as(barAlias)


Hvis vet en datasource først så kan vi finne select-sourcene ganske enkelt,
kan også komprimere de bra.

Trenger ikke from().
Men får ikke kompilert getterne uten from().

Så kan være nyttig med å ha en query-greie som på forhånd vet om entitetene.

private static final Select select = jpa("query-unit-noe");

Så kan vi cache de typene som behøvs, selv om mange å søke igjennom i starten.
Kan dele de statisk når vi bygger query.

Så vi må ha en kilde for type-info i så fall, da slipper vi from() som bare er redundant.
from() kan være fint for å se hva som er med i query så kunne være optional evt.

Uansett å vite på forhånd alle typer som kan oppstå.

select.sum(Foo::getFoo)
.where(Foo::getBar).gt(10)
  .and().lower(Foo::getBaz).startsWith("baz");


Så vi har et generelt "typespace" som vi sette inn i query.


====


Hvordan uttrykke query som JavaScript?
vi outputter JS-løkker som utfører and-en på data direkte.

Så vi må ha doOrLoop(<noe som representerer lista>) som genererer kode.

Så vi har en QueryExecutor som for JS bare samler opp JSen mens for Java regner ut resultatet.

Viktigste er å beholde samme optimaliserings-logikk i JS og Java med hva vi itererere først og siste, altså samme (enkle) query planner.

Men ikke vits i å optimalisere veldig i starten, mest å holde mulighetene åpne for dette.


===

OBS! Dynamiske queries? Med data som blir oppdatert asynkront i bakgrunnen. Har med paging å gjøre, første synlige element osv.
Kan holde første synlige element i lista stabilt og oppdatere resten i GUI dynamisk.
Samme problematikk som Nebula gallery.


===


TypeSpace:

- TypeSpace må kunne ha et API som gjør at kan bit-pakkes senere for å kun lage en enkel instans for ad-hoc queries.
Men for AdHoc er det mulig er mere aktuelt med å bare samle lambdaene.
Så to arrays. Issue er at vi ikke vet på forhånd hvor stort query er.

 - korte queries : et par-tre harkoda ops og lambdaer slik at holder med en enkelt instans i minne.
 - lange queries : arrays som vi lager etter hvert med opsjonene som trengs. Så vi allokerere arrays-ene så fort trengs for å eksekvere. Antakeligvis en god del raskere enn Streams
siden bare en enkelt allokering i enkle tilfeller.


- Men i starten er det prekompilerte queries som gjelder, for hvis ikke vil de ikke kunne anvendes for web.


- Vi ser ikke på om datasource er local eller remote, vi definerer JPA direkte og select()er ut av dise.

===

Tre-bygging. Må kunne bygge trær rett ut av selectene inn i result-VOer.
Må være hensiktsmessig i forhold til GUI-trær slik at kan select()e rett fra GUI (men DAO-lag ønskelig? Trenger da konkrete VO typer å jobbe på).
Antakelig det beste å ikke tillate select-er fra DB/persistent DS direkte fra views. Bør alltid gå gjnnom modellen, som returnere VOer av noe slag.


===

Bør ha query-API som ikke antar egne sub instanser? Men kan fikses senere.

===





---


- Kan ha conditions som er for flere kilder.
- alle join conditions må være spesifisert i joins
- 


- sorterer på source (alias eller klasse - er vel name egentlig)
- vi looper over og finner alle som matcher for å slippe gjøre noe med datastruktur. Må ha iterator-lignende for dette som opererer på indekser, dvs int.

 * når vi genererer query så emitter vi sjekk for hver enkelt av queryiene som matcher. Så vi finner hver enkelt i inputen som matcher "vår" join og emitter koden for denne
uavhengig.


Subselects ? Emittes som ekstra kall? Kan ha input parametre som skal matches for hver rad som er utført.



-----


Enkel non-set Join i løkke?

Må joine mot alle andre, så kan kun beregne joins helt til slutt i innester løkka?

Men joiner på andre felter, joiner på IDene mellom de.

Så slik sett på hvert nivå.
Men retning på joins? Joiner mot de som er tidligere i rekursjon for med de som er senere så joiner vi motsatt vei.




JPA joins? Må i første omgang joine på collections antakelig.
Så må ha en måte å spesifisere dette på.

Behøvs egentlig bare selve collection som skal joins på, men kan ha en verbos versjon her også.


join()

Burde ha bare on(foo::getFooBar)

Siden vi ikke joiner på felter. Men burde kunne custom-joine også som vi uttrykker enten i where-clause eller i JPA >= 2.1 joins.


----














----


		/*
			System.out.println("## generic return type: " + m.getGenericReturnType().getTypeName());
			
			final Type type = m.getGenericReturnType();
			
			final ParameterizedType genReturnType = (ParameterizedType)type;

			final Type collectionMemberType = genReturnType.getActualTypeArguments()[0];
			
			System.out.println("## generic return class: " + ((Class<?>)collectionMemberType).getName());
			
			
			System.out.println("## found collection attribute " + attr.getName() + " of type " + attr.getJavaType() + ", generic type " +
							Arrays.toString(attr.getJavaType().getTypeParameters())); // [0getGenericInterfaces()));
		*/




		
		final OneToMany oneToMany = accessible.getDeclaredAnnotation(OneToMany.class);
		
		if (oneToMany == null) {
			throw new UnsupportedOperationException("No one-to-many for ");
		}



		// Check whether target is same as toClass
		if (memberType == null) {
			memberType = oneToMany.targetEntity();
			
			if (memberType == null) {
				throw new IllegalStateException("memberType neither specified with generics nor through members");
			}
		}

		final Relation ret;

		if (memberType.equals(toClass)) {
			// Relation from one to other
			final RelationField from = new RelationField(fromClass, makeEntityAttribute(attr));
			final RelationField to = new RelationField(toClass, toEntity, findToAttrOrForMappedByException(toEntity, oneToMany.mappedBy()));

			ret = new Relation(from, to);
		}
		else {
			ret = null;
		}



----


Input API for resolve ?

 * Må scanne etter IDer for join-en basert på meta-modell.
 * hvis ikke finnes meta-modell så må vi se på innhold i selve listene og joine mot de? Dvs alle som har liste-element som inneholder slik-og-slik.

Hvordan oppgi meta-modell? Bør være noe i data-sourcen til POJOen i prepare?

Må ha et sette med metadata-scannes som legges inn.
Dette burde egentlig være i query-contexten som opprettes et annet sted.

select.first()

select = Query.pojo();

select = Query.universal();







Hvordan joine tilbake på innholdet? Må se på kolonna som har et gitt innhold.
Men gir dette egentlig mening? Er bare join tilbake på instansen. Så må finne den som inneholder link til instansen
		og sammenligne identity eller bare IDen.
		Om ikke er hverken i liste eller reverse så kan vi ikke joine.




----


Neste:

% - adhoc queries med mininmalt overhead
  ! IAdhocAndClauses er ikke typesafe, type parameteren må være typen vi opererer på akkurat nå. OBS! Dette bør kunne gjenbrukes
    for vanlige queries også siden gir mere strukturert syntaks.

  Hvordan skille disse? Er to forskjellige typer, Checked og Unchecked der adhoc er Checked.
  
# - rename av Class / Table => Entity (i motsetning til Alias) slik at blir konsistent.
Renamed til Named
#  - nøsta and/or
# - in
# - bedre debugging av in-memory query eksekvering
W - parametere

# - funksjoner lower(), trim() osv
#   * named
#   * alias
#   * adhoc
   !! * parametre i funksjoner? substring(1,2).of(Foo::getClass) for parametriserte, så ikke blir så mange kombinasjoner

 - query ut fra context variabel
   * forenklede queries uten from eller join sources. Trenger ikke from/implisitt join om kun ANSI joins
     siden from er der for cartesian product.
   * datasource må da oppgis først, slik at kompilering kan skje statisk.

 - fetch join
   kombinere i samme metodekall? .fetchInnerJoin(Company::getEmployees) eller .innerJoin().fetch(Company::getEmployees) eller fetch().innerJoin(Company::getEmployees) ? 

   .fetch().innerJoin() er vel mest nærliggende? Må huske å kombinere med koden for dette med .

 - isNull(), isNotNull()

 - result functions? dvs aggregates. count, etc

 - dialekter, dvs statisk begrense muligheter (kun ANSI joins? kun samme-type rekursjon? strict, short, classic)

  * joins bør være nøsta, slik som for adhoc query
    - viser letterer den logiske traverseringen mellom tabellene
    - lettere å implementere API-messig også siden sub-joinene blir decoupled.

 - having støtter ikke unresolved, se etter TODO i koden.
  
 - subselects
   * exists/not exists
   * any?

 - fikse nøsta and/or slik at ikke har mulighet for .compile()
 - fikse adhoc join-and/or slik at ikke har mulighet for .compile()

 - group by? innvirkning på traversering? traversering er separat
 - having?
   !! TODO having: må kunne sjekke mot aggregate-functions i and() og or(), så må kansje parameterisere functions som er retur-verdi her.!!

- where() uten parametre, bør fikse slik at alltid bruker list(alias) for entity queryis mot alias. For mapped så
vil vi kunne switche i mappinga.
 Men er samme issue for map():

- casting? ustandard.
- limit/offset - ustandard, men støttes av fleste databaser.

- databasespesifikke dialekter APIet? Mye jobb å teste og vedlikeholde så antakelig helst ikke.

- TODO where() for functions i short-queries, litt vanskelig om ikke vet result typen (named/alias) allerede, dbs for entities, siden
  må kunne finne denne rekursivt. altså list(SomeEntity.class).where().lower(SomeEntity.getName).isEqualTo("foo"))

- ikke tillate aggregates på toppnivå kun på joina typer? list(SomeEntity.class).where().sum(SomeEntity::getSomeMumber) ?
  Gir ikke mening dette queryet.

- map() for funksjoner
 * fortsett med å fikse query slik at henter sum osv
 * også fikse sqrt().avg() og avg().sqrt() osv
		
 * OBS! Også fikse count(*), må altså kunne mappes uten å velge noe source-felt.

- expression lists, mapOf() osv
 * mapOf() vil ikke fungere for initelle mappingen siden ikke vet om named eller ikke.
   Kan forsøke med å sende inn et initial-interface so støtter begge, men to metoder - med forskjellig retur-type i Function<> som er parameter:
     ISharedSubOperandEnd_Named eller ISharedSubOperandEnd_Alias. Ut i fra denne så klarer kanskje Java å returnere om er named eller alias
     hele veien tilbake. OBS! Må si så fall testes med multiple nivåer med nøsting hvor named konta alias bare er kjent i nøstede av nøstede nivåer.
  Evt bare lage mapOfAlias() og mapOfNamed() som fallback for initielle interface men dette hadde vært greit å unngå å måtte si om er named eller alias noe sted. 


 - !! TODO !! bør avg() returnere Double for BigDecimal? virker rart. Vil dette fungere for Long også eller kan Long ha verdier 
som er større enn double?

- Alltid list alias for entity alias query
   list(<alias>), one(<alias>), aldri list(<class>) eller one(<class). Så om er dette så går vi alltid til alias.
  MEN !! Vi kan fortsatt ha list/one(<class>) som går til alias - men bare for mapped queries.
Så ved where() så vet vi alltd om er named eller alias?
Også for aggregate, siden oppgir felt. Så burde aldri ha where() på ukjent om er named eller alias(). men map() på ukjent named eller alias har vi.

Men vi vet forskjell på Entity og Mapped ?
Entity - Alias : alltid ved oppstart
Entity - Named : alltid om ikke er mapped? Fra intial (så tregs initial)
Mapped - Named : alltid om mapped på name
Mapped - Alias : alltid om mapped på alias



# - order by?

#- group by, burde alltid etter where men også etter join? Kan
#trengs ikke alltid WHERE etter join om er kun join-resultatet vi er interessert i.
#OK, så vi må ha 3 interfaces:
#group by, having, order by.
#group by må være først, så having, så order by
#men de kan også fjenres, dvs having uten group by og order by uten noen av de.
 
# !! TODO: skiller mellom NonProcessResult og ProcesseResult i dag men burde skill ut OrderBy som egen
# siden ved liste av entiteter ("select * from" i praksis) så burde en ikke kunne gjøre group by eller having mens order by er OK.

#!! TODO !! 
#Flytte i generisk Collector_And_Or/Collector_And_Or_Named/Collector_And_Or_ALias og fjerne Classic_Collector_Where_Or_Join, heller implementere ISharedLogical_Where
#i *Classic* interfacene, slik at vi får gjenbrukt baseklassen i having.

Hva med having().sum() ?? Blir tilsvarende where-clause i WhereOrJoin.



#OBS!!
#	men order-by for entities, hvordan fikse?
		
#	har ikke rekkefølge på feltene.
#	Hmmm.., betyr at vi er nødt å sende gjennom om er Entity,
#	så alle kobinasjonenene.

#	Slik at MultiEntity kun har order-by og da kun på felter, ikke på liste (1, 2, 3) siden ikke vet hva dette innebærer i entity.


For adhoc er det alltid kun på felter? kan finne 1, 2, 3 der også ut fra mappings men for entity så må det være på felt.


#Hva er da kombinasjonene?
#Single/Multi? Vi burde alltid sende med om single og multi.
#Er en fordel å vite om mapped og select-criteia er jo mappinga å vi burde også vide dette på det tidspunktet.
#Så hva blir det da? Tre varianter så lang, så får en se om må splittes mere.


#Single
#MultiMapped
#MultiEntity

#Så NonProcessResult er da? Kun Single det, så 
#NonProcessResult => Single
#ProcessResult => MultiMapped


#- TODO: er det rett å alltid sende inn named for order by/group by?
#Kan returnere rader fra alias av samme type og da bør en kunne velge hvilke av disse en skal gjøre order by på?
#Så fikse dette i CompiledQuery og API slik at for alias baserte query så er det alias som sendes inn.

- TODO: for adhoc queries, hvis resultat er et vanlig Set<> så bør det ikke være mulighet å gjøre orderBy, måtte være sorted-set i så fall.
 

- TODO: list entities - må velge alias eller named på noe vis når ikke er mapped.
 kan velge i .from() men fungerer ikke om skal kutte from, så må da velge i første where.


 

- !!! for halway queries (startsWith/endsWith/in for native), fortsatt parametrisere for å unngå at logger verdier !!!
 * bør støtte både tidlig og sein resolve, arve JPAConditionToOperator fra ConditionStringBuilder og så arve fra der igjen?
 * fortsatt resolved/unresolved men unresolved også må kunne resolve via parametre, egen abstract-metode for det noe sted.
 * bør også kunne resolve alt til konkrete parametre om ønsker.

 * OBS! skille ut alt target-spesifikt i eget *Target hierarki for SQL genereringen, uavhengg av datasource (sinden kan kjøre native queries mot JPA f.eks)


- OBS!! Må være måte å spesifisere hvilke dialekt en skal bruke, på tvers av kodebase, dvs at velger ene eller andre dialekten
slik at er konsekvent gjennom kodebasen. Dette f.eks ved å arve fra et interface og så er det dette som anvendes.
Kan evt enable runtime-sjekker v.hj.a statics intern som sjekker at kun er en slags dialekt som anvendes.
Så det er start-interfacet som alltid bestemmer dialekt, kan ikke mikse og matche i samme query uansett.
  * !! NB !! kan også fikse dette compile-time med forskjellige jar-filer (dvs Maven dependencies), 1 per dialekt slik at kan velge bort.
    Kan da gjøre dialekten avhengig av base-fila slik at bare trenger inkludere en enkelt.


 - mere tester
 - unit tester rett på JPAModel og utils for å sjekke at henter ut relations riktig, attributt kolonner mm på rett vis.
   * se om bør endre API slik at eget for å hente kolonner for relation attributter?

 - transformasjons-API
 - optionals
 - JS / annen kode generering ut fra POJO joins
 - lagre/slette-API som er uavhengig av JPA
   * batch insert/update
 - hibernate direkte støtte? Mulig kan gjenbruke en del fra JPA



----



adhoc query

list()   .from(fooList) . where(Foo::getBar) . isEqualTo("baz");
one()    .from(fooList) . where(Foo::getBar) . isEqualTo("baz");
first(10).from(fooList) . where(foo::getBar) . isEqualTo("baz");

list(Foo::getBar).from(fooList).where(Foo::getBar).startsWith("baz")

sum(Foo::getBaz).from(fooList).where(Foo::getBar).startsWith("baz")

sum().from(intList).where().greaterThan(1);

sum(intList).greaterThan(1);


flatten(Foo::getSubs)
	.from(fooList)
	.where(Foo::getBar).startsWith("baz")
	.  and(Sub::getFoo).isEqualTo(1);













---



list(fooLis)
   .join(sub).on(Main::foo).isEqualTo(Sub::bar)
	.where(Sub::var).isLessThan(10)
   .join() 


list(fooLis)
   .join(sub, j-> j.on(Main::foo).isEqualTo(Sub::bar). 
		.join(subSub, j2 -> j2
			.on(Sub::bar).isEqualTo(SubSub::baz)
 			.where(SubSub:baz).isEqualTo(19))

		.where(Sub::var).isLessThan(10)
   .where()




---------


Hvordan fikse conditions etter joins?
Setter selectSourceIdx til siste kjente men denne har blitt inkrementert av join.
Dette gjelder også nøstede joins, vi må lagre unna den opprinnelige noe sted.

Kan benytte conditions idx direkte og sette denne tidlig, men hvordan finne tilbake?

Er vi på ytterste nivå kan vi anta source 0, for joins så må vi instansiere uansett så da kan vi mellomlagre der.



---


where-joins på innerste nivå stemmer ikke med ConditionsType.
Issue? Gjør det vanskelig med and-or kombinasjoner nedover i nøstinga.

and foo.x = 1
and bar.y > 2

Her joiner vi så ikke like lett å løse, får conditions som tilhører join'en i stedet.

Egentlig en nøsta and-or dette side vi joiner så er det AND mellom alle.
Så er "or" i en join så må vi nøste med and.

Og Join-API må støtte nøsting uansett.

Så en condition kan være SUB eller COMPARE, her blir det sub som peker til et sett med andre conditions. Men de kan ligge i samme tabellene.


Så hver join får sin egen sub, men bare om har joins. Men vi finner ut om har joins før conditions på topp-nivå.

Eller skal vi legge inn conditions på join-nivå i stedet ?

Skal uansett håndtere sub-conditions, hvordan? Kan ha en array av nøstede levels med indekser for sub-conditions som vi evaluerer nedover.

evaluateCondition(int [] indices)

Eller holde styr på en link? Men må vite når vi skal returnere tilbake

Det er i så fall getConditionCount() lignende som må brukes til å navigere.

E

int getSubConditionCount(int conditionIdx);

int getSubConditionStartIdx(int conditionIdx);


Og så anta at conditions er i stigende rekkefølge? I stedet for at sender inn array med hele pathen.

Hvis array så må vi sende inn en array av pathen som krever ekstra allokering.

Lage egen helper-klasse for management av arrayen? Eller utility-funksjoner.
Men er multiple arrays i ett tilfelle.

Men er kun om har subs eller joins at trenger arrays for disse.


--

For vanlige joins blir dette et litt underlig API siden må bruke samme algoritme for å ekspandere.

Så greit med en utility-klasse for management av arrayene ?






----



Joins:

 * implicit join i from-clausen
 * explicit join (ANSI join)

OBS! Kan ikke ha samme alias i begge, må fjerne fra from om finnes (m/warning?)

Bør tillate i query-generering men fjerne fra syntax, ihvertfall den forenklede.

Kun nøsta-joins? Men blir ikke typesjekking ved alias uansett.


Men har da to typer SelectSources
 - fra from
 - fra join

- Må kunne søke på de
- Må kunne fjerne from 'from' når er duplikat. Gjøre dette under kompilering og tildeling av indekser.


Så må endre noe på CompiledSelectSources ? Kan ha flere sources, både from og join.

Hvordan fikse indeks tildelingen i så fall?
Antalig best å oppdatere indeksene til slutt.

Hvis ikke må ha ett steg til i kompileringen.
Men bør ha dette uansett? Sources er uavhengig av from/to og disse opprettes i etterkant?
Omtrent som SelectSource.

Så bare en liste over kjente sources som vi søker i? med remove() osv.



----


Nøsta and/ors.


and(o -> o.where(Foo::getBar).			)


 - ser for mye ut som subselect
 + nøsta


and(o -> o.or(Foo::getBar).or()			)

 - or først ser rart ut

andAny(Foo::getBar).or(Bar::getBaz)
.and(Foo::) // and avslutter konteksten

 - avhengig av indenterug for lesbarhet, vanskelig å skille dobbel nøsting
 + kan vøre mere lesbart



.and(o -> o.any(Foo::getBar).or (Bar::getBaz) )

. or(a -> a.all(Foo::getBar).and(Bar::getBaz) )

 - fortsatt ikke kjempe lesbart
 + nøsta så parantesene sier hva som er logikken



##

Hvordan differensiere fra subselects? Funker ikke å bare sende inn en annen builder for da vil en få ambiguity?
Kan teste om så er tilfelle.

.and(s -> s.select().first(xyz).from()) . isEqualTo("123").

Kunne det lønt seg å sende inn verdien først? Er mere lesbart siden ellers vil .isEqualTo() forsvinne i andre koden, men om er først så blir det motsatt fra hva som er ellers.
Kan likevel virke litt for mye tilpasning å sny på flisa, man er vant til å skrive kolonne først, ikke parameteren. Så antakelig ok å sende inn query først.
Gjør også at vi vet at dette er en subselect og kan gjøre valg i builderen vi returnerer.

---

For adhoc queries, så MÅ vi kode typen rett inn i AND/OR interfacene for at skal bli riktig statisk typesjekking, ellers så kan en sende inn hva som helst,
dvs om er <T> i input interfacet i stede for i parameteren.
Så er et bra starting point å opprette eget her, slik at vi kan fortsette med IShared<> .

interfaces for and?
 - subinterface builder for any() og all() som har StringFunction osv (så blir en del duplisering .. men har ikke noen betydning her). Men ser ut som like greit å bare ha and() først.

 - returnerer samme som for topp-nivå and() eller or() og som retur-type for Comparatoene, dvs AndClauses eller OrClauses.


Hvordan lagre nøstingen? Må allokere ny instans. Bare gjenbruke query-klassen som vi har? Antakelig det enkleste, bare sette i rett initial-state.
Trenger ikke vite om er List eller Set her, kan ha AdhocConditionsNested siden vi uansett ikke skal gjøre get() for å hente ut noe resultat,
er kun for å lagre unna conditions.

OK stryk forrige, ser ut som AdhocConditions allerede er separat så kan bare nøste disse.


---

Bør rydde i table/entity/class


table:
 - database spesifikt, passer ikke med Pojo
 + ??

entity:
 - vagt
 + generisk
 + gjenbrukt i JPA


class:

 - pojo spesifikt
 + kjent



Kontra er alias

Det motsatte av alias er concrete kanskje, men tror satser på Entity


---


adhoc queries og order-by etc?

Dette er i grunnen relatert til result-set

 - returnere en enkelt entitet type fa lista ? Gjøre group-by på resultat-typen ??

   OBS!! Men egentlig ikke applicable siden er kun ved aggregeringer at er noe poeng å gjøre group by.
   having kunne gitt mening men kan vel ses bort far i første omgang.
   order by må vi ha for sortering av records.

 - når vi mapper resultat så kan vi gjøre order-by på det nivået på KUN den typen.
   Så da kan en faktisk også gjøre dette for vanlige queries, det er KUN resultat-typen en kan hente felter fra.

Så da kan vi altså for adhoc-queries gjøre groupby/having/orderby med akkurat samme API siden er resultat-typen som har noe å si.

Betyr vel også da at en egentlig ikke trenger alias her, det er alltid named, eller ??
	Nja, det kan være to aliaser av samme type i resultatet. MEN!! da skal dette være mapped så da er det mapped-typen som gjelder.
	Så ja, er alltid mapped.	

Så ikke alle queries vil kunne ha group-by kun de som gjør mapping. Så da må vi nok dra med oss propertien på om er mappa, hele veien igjennom.
Hvordan gjøre dette mest hensiktsmessig? Kan bli mange kombinasjoner av det, men kan ihvertfall sette kombinasjonene sammen av isolerte interfaces.


Må ende opp med en [IClassic|...]WhereOrJoinBuilder som da vet om den er mapped eller entity result.

MEN: er også slik at for queries som returnerer bare en enkelt-entry så er det meningsløst å ha result aggregerings funksjoner, så vi kan bare kutte disse helt.

Så egentlige er det bare "aggregational" vs ikke som trengs å sendes videre av informasjon, er vel ikke andre grunner til at ønsker dette?

Er to akser:
single vs multi
og entity vs mapped.

så om skulle sende all infoen så blir det 4 type interfaces som må sendes gjennom. Men siden er bare multi + mapped som gir mening å ha group by osv,
så kan man altså klare seg med to utgaver, hvor den ene utgaven bare returnerer default mens den andre vil ende opp med ekstra-funksjoner.
Dette er da fra WhereOrJoin utover.
Men må vel ha egne typer for Alias vs Named? 

Alt kan implementeres i samme klasser evt, trenger ikke ha egne collectors for dette.









----

POJO for group by/order by.

Hver rad er Object [].
Gjøre group-by fortløpende?


Er da i addToColl() fikser dette antakelig.

GroupBy? Må finne distinkte entries ut fra kolonnenene.
order by? TreeSet eller annen ordering metode?

Må kanskje abstrahere dette, men bør kunne gjøre begge deler.

Så implementere en egen result-collection bare, og så blir det adda til denne,
slik at kan ha forskjellige implementasjoner alt avhengig av.

har addToMapped, hvor vi mapper scratch til instance.
Må vel da gjøre om før den tid ?Dvs vi skal sortere på de nøklene som er i scratch-buffer, lettere enn å sortere på resulatet?
Vi grupperer og sorterer jo på getterne.

- Mapped => bruke indeksene for å finne rett verdi ut fra scratch buffer og sammenligne med mappa verdier?
Gjøre begge deler i samme.

- Entity => kun order-by, da må en gjøre order-by i collection som addes til med å sortere på getterne fra denne.

Så sender inn egen collection basert på hva som er tilfelle.

Men om mapped så bør en vel fikse dette i samme som mapper over resultatet, så da adder en scratch-greia i stedet og fikse mappinga der,
så slipper en å gjøre unntak.


Order-by på:

 - flere felter? Må bare lage en array av disse som vi sammenligner.
 
Group-by ?
 - grupperer nedover, her er det enklest å bare lage instanser i første omgang så kan vi gjøre order by senere.



!! OBS !! Må sammenligne CompiledFieldReference når finner indekser slik at alltid velger rett alias.
Hmmm... men vi sender alltid inn named her.




---------------


aggregate functions:

 .map(foo::bar).to(baz::baz)
 .sum(foo:baz).to()..

Så mapperen må arve fra disse.



--



	
	hmmm.. vanskelig å returnere noe generisk her pga T, som må være med i retur-verdien.
	men vi  har T som en return i where-clauses og denne må da returnere bare noe som også er T
			
			
	men i en annen type, så det er da INTEGER_RESULT osv,
	
	Så for vanlige queries så blir det ikke like mange.
			
			

----------------------------------------------------------------------------------------------------

Rydding i kode:

For having-clause må vi sørge for at havner i rett Collector_Clause, eller nærmere bestemt havner i having-clauses i QueryCollectorImpl
og ikke noe annet sted.

For å fikse dette bør QueryCollector kalles fortløpende etterhvert som vi switcher fra en fase til en annen i query collection,
f.eks i GroupBy, når vi enten kalles med orderBy() eller having() så collecter vi group-by clausen over, og tilsvarende for having().
Dette betyr da at vi slipper å passe igjennom alle disse parameterne hele tiden, det er kun dette ene collector-interfacet (eller klassen).
Da spiller det ikke lengre noen rolle hvor få eller mange instanser vi lager på veien, så lenge vi bare lagrer i collector'en der vi går over fra en fase til en annen.


Vi må også rydde i mekanismen som gjør query-generering => få dette ut av datasource osv. Dette fordi:
 - enklere å skille ut varianter og sub-varianter.
 - datasource er egentlig uavhengig av query, DS er Hibernate/JPA/JDBC ol hvor man kan gjøre native queries mot div database som krever forskjellige typer query-generering helt uavhengig.
 - slipper subklasser i PreparedQueryBuilder og Conditions-Builder. Disse vil bare bry seg om basis-strukturen. Kan hende at er noen forskjeller mellom .
 - kan rydde i disse half-way greiene slik at blir mindre error prone, ved at finner ut tidlig om er half-way og da separere alt før/etter where evt bare gi blanke i half-way og generere hele smæla om ikke kan resolve på en gang, da er det samme koden som kjører på alle parameterne og blir enklere å forholde seg til.


-------------------


Hvordan splitte i query generator? Kalle det QueryDialect? Kanskje grei den, for å være konsekvent.

Må lage en abstract-klasse for disse og så metoder som emitter de forskjellige.

Er PreparedQueryBuilder treet vi kvitter oss med da. Men kan fortsatt ha PreparedQueryBuilder ut i fra struktut, men med noen abstracts
i QueryDialect for å skille mellom basis-forskjeller som om er TOP() eller LIMIT og OFFSET.





-------------
mere generisk switch mellom query-deler for strict/classic/short og kunne gjenbruke/kombinere?

 - single aggregate => from
 - single scalar column => from
 - single row => entity / mapped
 - entity => from | where/join
 - mapped => from | where/join
 - from => where/jpoin
 - mapped => where/join

 - where/join => group by
 - where/join => order by

 - group by => having

for 'short' så er alt like, bare skippe From. Så er ikke IClassic lengre, er ISQL.

Fordel med å skippe 'from': slipper cartesian product feil, er alltid ANSI join.

Kan hende også ikke behøver disse Multi osv kombinasjonene lengre? Vi er bare interesser it GROUP_BY clausen.


-------------

short-queries:

list(Company.class).where(foo::get)


vet ikke om er namedøre eller ikke før er i where-clause."

Så må wære where-or-join på begge.
Men dette gjelder også for short-utgaven, så lenge ikke er mapping.

Hvordan blir API? Blir fortsatt one() og list() men kan kalle where() og join()
uten noe annet.
Så må wrappe where-funksjonaliteten i så fall.


Hvordan skal vi mappe til prepared?

- compiled - har collecta query (m/eller uten å resolve til Method).
 evt Collected 
- prepared - knytta til datasource

Kan lønne seg å skille internt mellom Collected og Compiled? Begge kan bli prepared v.hj.a datasource

Men vi må altså ha to forskjellige utg punkt, datasource eller ikke.

Kan være nyttig å preppe til slutt om skal kjøre query på multiple DSer.

 - static, velger stil direkte med import-static.
 - typed, velger stil direkte mot en variabel? Er bare å assigne variabelen til f.eks IShortSelect.get(), må preppes til slutt.

 - med DS: style + DS. get(datasource)


DataSource? 
Merge test-greia inn i datasource slik at kan gjøre commit/rollback osv også, men er interne klasser.

Må ha en factory-greie for DataSource, eller bare en constructor?
Provider-pattern? Tungvindt? 
  - new direkte på klassen? new QueryDataSourceJPA("persistence-unit")
  - factory? Vanskelig siden multiple units.
  - konfig-pattern, nok det beste 
    * QueryDataSourceJPA() er konfig som sendes inn, en factory returnerer en implementasjon av datasourcen
    * Kan bytte implementasjon for samme konfigen, konfigen over sier bare at baserer seg på JPA entity modell.

      - kombinasjon JDBC kall/JPA entity modell? To forskjellige modeller? Kan være factoryen en kaller + konfigurasjon som sendes.
     
- !!OBS!! join-på-liste er kun når har en JPA-modell så bør være type-safe input parameter til factory-metoden som
 avgjør hvilke egenskaper som er i entity-modellen. Her kan vi benytte oss av Type1 & Type2 generics for div kombinasjoner.

Hva kalle dette?
Er ikke Persistence siden er samme som JPA så greit og ikke blande, og er heller ikke persistent siden kan kjøres
mot in-memory. Bare Data eller Query? Herer nå DataSource. Så kaskje bare ha en static DataSource?

DataSource.init(DataSourceConfig config)
Hva med query-styles? Er query-stylen som initialiserer.

ShortSelect.init(DataSourceConfig config), så kan da legge datasource intialisering i baseklassen, men stylen blir med i query-resultat?
Eller ihverfall i builderen.
Om skulle bytte så måtte sendt inn interfacet som parameter, så bedre å bare passe configen


Hvordan returnere annen type for get?

 Bør være forskjellig prepare, alt etter som returnert. Men vi har compile() som base
som er implementert i de forskjellige så ikke så lett å differensiere uten egne
sub-interfacer for alle,l så tungvindt og mye arbeid.


 .get() => hente verdier fra prepared-query

Men først prepared.
>zxcvbnm,.-+
m
1|++
Men om er med DS så blir det alltid prepared som kan gjøres executeWithParams() på.

Men hvordan skille mellom compile(), prepare() og prepare(ds) ?
Kunne vi prepare query etter-hvert, slik at alltid cast'er til PreparedQuery?
Da måtte alle interfaces implementere dette og så for hvert steg gjøre partial compile i stedet for bare
collect, dvs compile etter hver condition osv.
Noe trøblete å få til siden må skjule dette i interfaces hele veien gjennom?
Må bygge query på slutten. Men egentlig ikke værre typemessig enn det er om skal skille prepare() og prepareDS() siden dette uansett må skilles
i retur-typen.

Er ganske mange forskjellige siden blir kombinasjon med SingleResult/MultiEntity/MultiMapped og er mange interfaces som kan være siste-kriterie i query.

Om alltid hadde et ekstra-nivå så hadde vært enklere siden bare hadde sendt gjennom en egen MODEL.
Så alltid .build() , som returnerte prepared ellers, build().prepare(DS) om ikke. Dette er vel egentlig greit nok, at alltid må slenge på build() (== compile) på slutten?

Kunne evt ha prepare(DS) i et query som allerede hadde DS og så fjerne kaste exception runtime på dette.
Da måtte end-clausen ha get() men forvirrende.

Greit med compile()/build() inntil videre, er fullt mulig å legge til bakover-kompatibilitet senere om gjør slik at ikke behøver build() men at 
kompilerer etter hvert som query kjøres gjennom.



------------------------------



Short-query joins:

 - alltid joine nedover i en trestruktur, selv om kunne joine på toppnivå,
   gir bedre overblikk over layouten i dataene.


Må alltid ha en rot-type å joine ut fra.

entity:
  - rot-typen er i list() så kan bare joine ut rett etter denne.

mapped:

 - vet ikke rot-typen siden ikke spesifiser, letteste er nok spesiell join ytterst der rot-typen må med, eller?
Kan bare ha en enkelt join på rot-nivå så starter der.


 list(Mapped.class)
  .map(Company::getName).to(Mapped::setName)
  .map(Employee::getId).to(Mapped::setEmployeeId)


  .leftJoin(Company::getId, Employee::getCompanyId)....

  .leftJoin(Company::getEmployees) // men har vi liste-typen vi joiner til? Bør finne med annotations

  // multiple felter
  .leftJoin() .on(Company::getId, Employee::getCompanyId)
	     .and(Company::getId2, Employee::getCompanyId2)


Oppsummert:

Vi trenger ikke noen egen "from" MEN !! For entity-join så må alltid "from" typen i øverste join være
det fra lista mens for mapped så kan det være hvilken som helst type.


Nøsta joins:

  .leftJoin() .on(Company::getId, Employee::getCompanyId)
	     .and(Company::getId2, Employee::getCompanyId2),

		j -> j.leftJoin(Employee::getPersoin))

fungerer ikke.
Så må antakelig nøste på utsida slik som for adhoc:
  .leftJoin(j -> j.on(Company::getId, Employee::getCompanyId)
	         .and(Company::getId2, Employee::getCompanyId2)
                 .leftJoin(Employee::getPersoin))

		

Hva om vi bare skal nøste nedover uten multiple joins på samme? Kunne laget forenkling
men kan være forvirrende å vite hvilken nøsting vi er i - for valig SQL så kan en joine sub-entries på toppnivå
så litt forvirrende.

  .leftJoin()
	.on(Company::getId, Employee::getCompanyId)
	.and(Company::getId2, Employee::getCompanyId2)

		.leftJoin(Employee::getPerson)



Hmm.. kan hende vi ønsker å joine på noe annet enn det vi søker ut av entity,
så da må vi alltid velge root i join.

Kunne det tenkes å ha flere røtter, uten et join-query? Men da er det cartesian i prinsipper, så alltid ha en join-root,
men kan defaulte til valg entity.

Så hvordan blir denne da is å fall ?

.joinRoot(foo) om skal bytte, men kun mulig bare en enkelt gang.


UPDATE !! 

Alltid bare join'e på første typen, så blir det likt mapped. Så da vet vi ikke from-typen, og må ha egen from
på det som ikke er i interfacet, men det kan fungere likevel.
Men blir flere join-interfacer av det.

Men må altså til uansett for mapped, er da <FROM, TO> som egene typer, så har retur-typen FROM satt.

Men da kan vi ikke sende inn ret-typen som en generic-type heller, siden vi vet må ha type på denne.
Så join-rutinene må legges på helt ytterst, for at skal bli rett.

Så for hver WhereOrJoin så er det en initial og en vanlig.


Eller ???

Vi må vite hva som er lhs ? Men vi vet dette for collection-joins allerede, dvs det vil være synlig i query.
OK, så hvordan fikse Initial når får samme signatur som named-basen som er i SQLCollector_WhereOrJoin base?
Er samme erasure, så hvordan fikse?
Hjelper ikke bare å flytte interface ned siden fortsatt kræsj på metode.

Så må ha SQLCollector_WhereOrJoin_Initial_Base og SQLCollector_WhereOrJoin_Typed_Base

Men : blir mye kopiering i arve-trærne nedover om skal splitte på typed og untyped join her?
Eller vil vi alltid være over på typed-join tidlig? kun hvis er join, og kan være undecided frem til da.

Så hvordan kan vi da skille uten å få kræsj i interfacene ?
Etter where() så har vi ikke dette issuet lengre.

Så vi har dim/result/access men disse sier ikke noe om hvor vi er, med unntak av result, som sier om vi er ferdig med mapped/entity.
Så før vi vet mapped/entity så er det alltid initial-join ? eller egentlig ikke join i hele tatt? bortsett fra ved valg av Entity,
så Any-typen på result må implementere initial-join.'


OK, så alle joins må implementeres i løv-klassene eller i den retning der det behøvs, mens alle aliaser
kan behandles i baseklassen siden ikke klarer typesjekke disse uansett.
For Named så bør en da bare lage bra aksessmetoder i baseklassen.


----


where() logikk, får kræsj på named vs alias.

Så da gjør vi slik at:
 - hvis list(alias) => aliased
 - list(Class) => named så blir da ALLTID named i dette tilfelle'

Men hmm.. dette fungerer ikke for mapped.
MEN! Hvis er mapped så kan vi endre her igjen. Men blir named HVIS en endrer rett til where()

Hva med map() ?


samme for one().


MEN: burde vi heller hatt en egen where her? Kan vi legge til senere.

Tror kan være greit å si at alltid må gjøre list(alias) uansett for aliaser.


===========================================================================================

Testplan:

Trenger ikke teste alt mulig av tilfeller her men en må spesielt teste de punktene der en "brancher ut".

Dette er en tabell med mange dimensjoner.

Akser:

funksjon | entity/mapped |  single / multi | joins 


group by | entity (N/A)|  single / multi | named / alias |


Hvordan best visualisere / fremstille dette uten dobbelt-lagring?

Det er nå først og fremst entity/mapped hvor det er unntak og unntakene er også ganske få (f.eks ikke group-by på entity).


OBS! Bør også test at en del syntakser ikke er kompilerbare, altså at ikke er kompilerbrart med group-by,
at joins må være av rett from-type osv, kan bare kalle javac i ekstern prosess.


Hvordan fremstille test-plan?

Er altså N/A vi er interessert i, og funksjonalitets kombinasjonene (dvs "having" kun hvis "group by").


Som er en dependency problemstilling.

enum Functionality {
   
  private Functionality [] dependants;

}


Og så liste over når en functionality *ikke* er applicable.

enum EFieldMapping {
  NAMED,
  ALIAS;


// Alle kombinasjoner innenfor det som er spesifisert her er not applicable.
class NACase {
  Functionality functionality;
  EQueryResultType [] resultTypes;
  EFieldMapping [] mappings;
  EQueryDimension [] dimensions;
}


Så må vi finne grafen av tilfeller som vi kan finne ut?

result => mapping => join => where => groupby => having => orderby => limit => offset


limit og offset har NA på query dimension single, f.eks.

Så da behøver vi egentlig bare å starte fra toppen her og rekursere ned igjennom for å få ut alle tilfellene.
Det kan bli ganske mange så vi kan sikkert eliminere noen, det ser vi når vi går nedover. Men vi må nok ha named og alias for alle.

Hvordan kan vi organisere selve testene? Må være et system i dette? 
Antakelig best å benytte seg av rekkefølgen over i navngivingen av filer.

AggregateMappedJoinWhereGroupByHavingOrderByLimitOffsetTest.java hmm... Eller med underscores.

Da kan egentlig test-rutina klare å finne ut hvilke tester som mangler med reflection, dvs Class.forName("...")

Hva er så innholdet i hver test-klasse? Det blir alle casene for den testen, her kan vi lage tomme tester også ganske enkelt

 testAggregateSingleNamed(), testEntityMultiAlias() osv.


Da burde vi ha ganske bra dekning av APIet, slik at unngår ClassCastException pga manglende interface implementasjoner, og den type ting.


Så er det noen spesial-greier slik som functions og ikke functions, disse kan da være på en separat akse av testing,
så ikke blir så mange kombinasjoner. F.eks så har functions i mappinga som lower(Foo::getBar) ikke noe særlig å si for hva som skjer
 i where-clausen så kan lage egne kombinasjoner her innafor kun mappinga f.eks.


Så kan en også ha noen adhoc smoke-tests som sjekker litt slike kombinasjoner også.

Bør kjøre cobertura etter hvert, spesielt viktig for join-semantikken.

Variants? Må modellere varianter under hver, som er uavhengige? Men disse må testes for seg.


----

 - multiple datasources, hver test kjører multiple ganger så må slette ut databaseinnholde.
Men dette er vel gjort i check()?


Så det er en tre-struktur av mulig sekvenser gjennom treet.

start => aggregate osv, hvordan modellere valgene? Gjennom alle som kan være foregående?
Men hva om er avhengig av noe lenger fremme i pathen ? Er her NA_CASE kan anvendes. Men stort sett er det ikke noe slik.










=====


!! created collector Short_Collector_Multi_Any_Any with collector QueryCollectorImpl [result=null, mappings=null, sources=null, joins=null, clauses=null, groupByCollector=null, orderByCollector=null, orderByColumns=null]
!! created collector Short_Collector_Multi_Mapped_Named_Initial with collector QueryCollectorImpl [result=com.neaterbits.query.sql.dsl.api.CollectedQueryResult_Mapped_Multi@c1fa7d4, mappings=null, sources=null, joins=null, clauses=null, groupByCollector=null, orderByCollector=null, orderByColumns=null]

!! created collector SQL_Collector_And_MultiMapped_Named from SQL_Collector_And_MultiMapped_Named with collector QueryCollectorImpl [result=com.neaterbits.query.sql.dsl.api.CollectedQueryResult_Mapped_Multi@c1fa7d4, mappings=com.neaterbits.query.sql.dsl.api.MappingCollector@3f1ddac2, sources=null, joins=null, clauses=null, groupByCollector=null, orderByCollector=null, orderByColumns=null]

!! created collector Collector_GroupBy_Named from Collector_GroupBy_Named with collector QueryCollectorImpl [result=com.neaterbits.query.sql.dsl.api.CollectedQueryResult_Mapped_Multi@c1fa7d4,
 mappings=com.neaterbits.query.sql.dsl.api.MappingCollector@3f1ddac2, sources=null, joins=null, clauses=null, groupByCollector=null, orderByCollector=null, orderByColumns=null]


!! created collector Collector_Having_Named from Collector_Having_Named with collector QueryCollectorImpl [result=com.neaterbits.query.sql.dsl.api.CollectedQueryResult_Mapped_Multi@c1fa7d4, mappings=com.neaterbits.query.sql.dsl.api.MappingCollector@3f1ddac2, sources=null, joins=null, clauses=null, groupByCollector=com.neaterbits.query.sql.dsl.api.Collector_GroupBy_Named@4bafe935, 

orderByCollector=null, orderByColumns=null]



- having er  i annen clause, så må enten returnere claus-en som sendte oss dit, eller så noe annet.
Issue er at vi samler conditions i Collector_Conditions_Base og da sletter vi de gamle tydeligvis, siden de ikke settes etter at vi gjør having().

 * sette der i QueryCollectorImpl?
 * alltid sette i QueryCollectorImpl? Vet ikke om er conditions eller having. Hva er beste måte å differensiere her?

Vi må vite om er having eller where i det vi instansierer og så må all collection bare kalles på query-collectoren? Men vet altså ikke hvilken vi er i.

Kunne alltid satt conditions når vi exiter
 => groupBy
 => orderBy
 => build()

.having()

Evt abstract-metode som returnerer hvor den skal lagre clause ved construction.
Kan sette de i begynnelsen også men krever at vet at er conditions, og ganske mange steder instansierer.

abstract-methode fungerer dårlig, se på ConditionsClause? Kan se på original-clause? eller type.
Må alltid ha type i Collector_Clause, så kan bruke denne til å sette? Dvs EConditionsClause.

Collector_Clause har alltid dette, men denne lagres unna.



